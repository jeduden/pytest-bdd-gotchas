# Pytest Marks, Keywords, Parameter IDs and Pytest BDDs Parameterization, Tags

## Bugs and issues regarding marks, keywords and parameter IDs

Effort to fix these: https://github.com/pytest-dev/pytest/projects/1#card-4588520

### Symptoms

#### Tests with single parameterization where values have marks -m doesn't select parameterization

This happens if id's are identical with marks.

`make select_marked_params_with_ids/symptom` runs the following test:

    @mark.parametrize(
        ['a'],
        [
            mark.MarkA((1,)),
            mark.MarkB((2,))
        ],
        ids=[
            "MarkA",
            "MarkB",
            ]
        )
    def test_overlap_marks_and_ids(a):
        pass

Running `py.test` with `-m MarkA` selects 0 tests


##### Work around: Prefix ids

Never let the id namespace overlap with the mark space. I.E.:

prefix ids with "idForMark"

Drawback if running the suite you'll see the test with parameter ids but not the actual mark names:

    test_overlap_marks_and_ids[idForMarkA] - PASSED
    test_overlap_marks_and_ids[idForMarkB] - PASSED

in order to select one of these you need to run

    py.test -m MarkA 

and not:

    py.test -m idForMarkA 

See `make select_marked_params_with_ids/workaround` the result of `py.test -m MarkA`

##### Work around 2: Use -k

You can use:

    py.test -k MarkA

However, -k doesn't support operators: "AND", "OR", "NOT". 
It might also run tests where ids (unintentially having the same name as the mark)


    @mark.parametrize(
        ['Mark'],
        [
            (11,)),
        ],
        ids=[
            "MarkA",
            ]
        )
    def test_with_id_but_no_marks(a):
        pass

`py.test -k MarkA` will select the test. As expected, `py.test -m MarkA` will not select the test. See `make select_marked_params_with_ids/workaround_with_k`. 

##### Work around 3: Introduce a new parameter

Since the issue only occurs for functions with a single parameter. Introducing the dummy parameter helps.

`make select_marked_params_with_ids/workaround_with_dummy` runs the following test:

    @mark.parametrize(
        ['a'],
        [
            mark.MarkA((1,)),
            mark.MarkB((2,))
        ],
        ids=[
            "MarkA",
            "MarkB",
            ]
        )
    @mark.parametrize(
        ['dummy'],
        [
	    ("dummy",)
        ]
        )
    def test_overlap_marks_and_ids(a, dummy):
        pass

using `py.test` with `-m MarkA`.


#### Fixtures with parameterization such as aiohttp loop result in exception when used in given statement with parameters used by test generated by scenarios

    @mark.parameterize(['a'], [
    mark.MarkA((1,)),
    mark.MarkB((2,))
    ])
    def my_fixture(a):
    return a


    @given('some <param>')
    def my_given(param, my_fixture):
    return client

fails with if the scenario was generated by scenarios function of pytest bdd
 â€œFailed: The requested fixture has no parameter defined for the current test."

##### work around

pytest.usefixture put the fixture name there

     pytest.usefixture('my_fixture')
     scenarios()

This will inject my_fixture into the functions that scenario's generates and solve the messing fixture parameter.


#### Pytest-BDD's tags and keywords

When a scenario is tagged in a feature file pytest BDD calls pytest_bdd_apply_tag to let you translate this tag to a pytest mark (or something else)

When you try to decorate the test function with something else than a mark, the property that you choose becomes a mark anyway.

     @scenario
     def test_
    
     def pytest_bdd_apply_tag(tag, func):
         func.__custom = tag


     py.test --m __custom 

will select the test.

#### Pytest-BDD's tags and pytest_generate_tests

pytest_bdd_apply_tag is called before pytest_generate_tests. This means if you apply a mark directly in pytest_bdd_apply_tag and then parameterize the test in pytest_generate_tests each of the parameterization's will have the mark. 

